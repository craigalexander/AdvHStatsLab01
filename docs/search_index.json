[["index.html", "Statistics Tutorial 1 Part 1: Intro to R and RStudio 1.1 Intended Learning Outcomes 1.2 R and RStudio 1.3 RStudio Quickstart Guide 1.4 Credit where credit is due", " Statistics Tutorial 1 Part 1: Intro to R and RStudio 1.1 Intended Learning Outcomes Be introduced to R and RStudio Be able to load add-on packages Be able to get help for packages and functions Be able to create objects by writing and running R code 1.2 R and RStudio R is a programming language that you will write code in and RStudio is an Integrated Development Environment (IDE) which makes working in R easier. Think of it as knowing English and using a plain text editor like NotePad to write a book versus using a word processor like Microsoft Word. You could do it, but it would be much harder without things like spell-checking and formatting and you wouldn't be able to use some of the advanced features that Word has developed. In a similar way, you can use R without RStudio but we wouldn't recommend it. RStudio serves as a text editor, file manager, spreadsheet viewer, and more. The key thing to remember is that although you will do all of your work using RStudio for this course, you are actually using two pieces of software which means that from time-to-time, both of them may have separate updates. 1.3 RStudio Quickstart Guide The R software gives the computer the ability to process the R programming language. We will never use that software directly. Instead, we will use RStudio, an integrated development environment (IDE) which runs R for us via a graphical user interface (GUI) . Once you have opened RStudio, to create a text file (called an \"R script\") to write your R code in select from the menu: &gt; File &gt; New File &gt; R Script To save the R script file, go to &gt; File &gt; Save A dialogue box will appear asking where (on which drive) you would like to save the code. Save this R script file with a relevant filename, e.g. \"Statistics_Tutorial\". Once saved in a .R script file, you can use your code again, so there's no need to type it in a second time. If you close RStudio and then open it again you can read in your code by going to &gt; File &gt; Open File and find the code file from the location where you saved it. The RStudio IDE is arranged with four window. Figure 1.1: The RStudio IDE By default, the upper left pane is the source pane, where you view, write, and edit code from files and view data tables in a spreadsheet format. When you first open RStudio, this pane won't display until we open a script file (like we did above) or load in some data. We 'run' (i.e. execute) code in the script file by selecting the row(s) we want to run and then clicking the Run icon OR by holding down the ctrl key and Enter key at the same time. The results of executing the code (if any) appear in the lower left pane. The lower left pane is the console pane, where you can type in commands and view output messages. You can write code in the console to test it out. The code will run and can create objects in the environment, but the code itself won't be saved. You need to write your code into a script in the source pane to save it. The right panes have several different tabs that show you information about your code. The most used tabs in the upper right pane are the Environment tab and the Help tab. The environment tab lists some information about the object that you have defined in your code. We'll learn more about the Help tab in Section 2.1.5. In the lower right pane, the most used tabs are the Files tab for directory structure, the Plots tab for plots made in a script, the Packages tab for managing add-on packages, and the Viewer tab to display reports created by your scripts. 1.4 Credit where credit is due This introductory lab incorporates and adapts materials from: Nordmann, E. &amp; DeBruine, L. (2022) Applied Data Skills. v1.0. Retrieved from https://psyteachr.github.io/ads-v1/ doi: 10.5281/zenodo.6365077 and Hill, A. (2022) Data Visualization in the Tidyverse: The Great Tidy Plot Off. Retrieved from https://alison.netlify.app/uo-tidy-bakeoff "],["getting-started-using-rstudio.html", "2 Getting started using RStudio 2.1 Packages and functions 2.2 Objects and the assign (&lt;-) operator 2.3 Getting help 2.4 Further Resources", " 2 Getting started using RStudio 2.1 Packages and functions When you install R you will have access to a range of functions including options for data wrangling and statistical analysis. The functions that are included in the default installation are typically referred to as \"base R\" and you can think of them like the default apps that come pre-loaded on your phone. One of the great things about R, however, is that it is user extensible: anyone can create a new add-on that extends its functionality. There are currently thousands of packages that R users have created to solve many different kinds of problems, or just simply to have fun. For example, there are packages for data visualisation, machine learning, interactive dashboards, web scraping, and playing games such as Sudoku. Add-on packages are not distributed with base R, but have to be downloaded and installed from an archive, in the same way that you would, for instance, download and install an app on your smartphone. The main repository where packages reside is called CRAN, the Comprehensive R Archive Network. There is an important distinction between installing a package and loading a package. 2.1.1 Installing a package This is done using install.packages(). This is like installing an app on your phone: you only have to do it once and the app will remain installed until you remove it. For instance, if you want to use an app on your phone, you install it once from the App Store or Play Store; you don't have to re-install it each time you want to use it. Once you launch the app, it will run in the background until you close it or restart your phone. Likewise, when you install a package, the package will be available (but not loaded) every time you open up R. For example, to install the tidyverse package on your system: # Type this in the console pane install.packages(&quot;tidyverse&quot;) This package is the main package we will use throughout these labs for data wrangling, summaries, and visualisation. If you get a message that says something like package tidyverse successfully unpacked and MD5 sums checked, the installation was successful. 2.1.2 Loading a package This is done using the library() function. This is like launching an app on your phone: the functionality is only there where the app is launched and remains there until you close the app or restart. For example, when you run library(rio) within a session, the functions in the package referred to by rio will be made available for your R session. The next time you start R, you will need to run library(rio) again if you want to access that package. For example, you can load the tidyverse package for your current R session as follows: library(tidyverse) You might get some red text when you load a package, this is normal. It is usually warning you that this package has functions that have the same name as other packages you've already loaded. 2.1.3 Using a function A function is a name that refers to some code you can reuse. We'll start by using functions that are provided for you in packages, but you can also write your own functions. After the function name, there is a pair of parentheses, which contain zero or more arguments. These are options that you can set. In the example above, the data argument is set to ggplot2::diamonds, which refers to a built-in dataset diamonds from the ggplot2 package. If you type a function into the console pane, it will run as soon as you hit enter. If you put the function in a R script file in the source pane, it won't run until you run the script. 2.1.4 Tidyverse tidyverse is a meta-package that loads several packages we'll be using in these labs, including: ggplot2, for data visualisation readr, for data import dplyr, for data manipulation 2.1.5 Function Help When you load the tidyverse it automatically loads all of the above packages, however, it can be helpful to know which package a function comes from if you need to Google it. If a function is in \"base R\" or a loaded package, you can type ?function_name in the console to access the help file. At the top of the help it will give you the function and package name. If the package isn't loaded, use ?package_name::function_name or specify the package in the help() function. When you aren't sure what package the function is in, use the shortcut ??function_name. # if the package is loaded ?select help(&quot;select&quot;) # works whether or not the package is loaded ?dplyr::select help(&quot;select&quot;, package=&quot;dplyr&quot;) # shows a list of potentially matching functions ??select Function help is always organised in the same way. For example, look at the help for ?dplyr::select. At the top, it tells you the name of the function and its package in curly brackets, then a short description of the function, followed by a longer description. The Usage section shows the function with all of its arguments. If any of those arguments have default values, they will be shown like function(arg = default). The Arguments section lists each argument with an explanation. There may be a Details section after this with even more detail about the functions. The Examples section is last, and shows examples that you can run in your console window to see how the function works. 2.1.6 Arguments You can look up the arguments/options that a function has by using the help documentation. Some arguments are required, and some are optional. Optional arguments will often use a default (normally specified in the help documentation) if you do not enter any value. As an example, look at the help documentation for the function sample() which randomly samples items from a list. ?sample The help documentation for sample() should appear in the bottom right help panel. In the usage section, we see that sample() takes the following form: sample(x, size, replace = FALSE, prob = NULL) In the arguments section, there are explanations for each of the arguments. x is the list of items we want to choose from, size is the number of items we want to choose, replace is whether or not each item may be selected more than once, and prob gives the probability that each item is chosen. In the details section it notes that if no values are entered for replace or prob it will use defaults of FALSE (each item can only be chosen once) and NULL (all items will have equal probability of being chosen). Because there is no default value for x or size, they must be specified otherwise the code won't run. Let's try an example and just change the required arguments to x and size to ask R to choose 5 random letters (letters is a built-in vector of the 26 lower-case Latin letters). sample(x = letters, size = 5) ## [1] &quot;z&quot; &quot;v&quot; &quot;y&quot; &quot;w&quot; &quot;j&quot; Why are my letters different to your letters? sample() generates a random sample. Each time you run the code, you'll generate a different set of random letters (try it). The function set.seed() controls the random number generator - if you're using any functions that use randomness (such as sample()), running set.seed() will ensure that you get the same result (in many cases this may not be what you want to do). To get the same numbers we do, run set.seed(1242016) in the console, and then run sample(x = letters, size = 5) again. Now we can change the default value for the replace argument to produce a set of letters that is allowed to have duplicates. set.seed(8675309) sample(x = letters, size = 5, replace = TRUE) ## [1] &quot;t&quot; &quot;k&quot; &quot;j&quot; &quot;k&quot; &quot;m&quot; This time R has still produced 5 random letters, but now this set of letters has two instances of \"k\". Always remember to use the help documentation to help you understand what arguments a function requires. 2.1.7 Argument names In the above examples, we have written out the argument names in our code (i.e., x, size, replace), however, this is not strictly necessary. The following two lines of code would both produce the same result (although each time you run sample() it will produce a slightly different result, because it's random, but they would still work the same): sample(x = letters, size = 5, replace = TRUE) sample(letters, 5, TRUE) Importantly, if you do not write out the argument names, R will use the default order of arguments. That is for sample it will assume that the first value you enter is x. the second value is size and the third value is replace. If you write out the argument names then you can write the arguments in whatever order you like: sample(size = 5, replace = TRUE, x = letters) When you are first learning R, you may find it useful to write out the argument names as it can help you remember and understand what each part of the function is doing. However, as your skills progress you may find it quicker to omit the argument names and you will also see examples of code online that do not use argument names, so it is important to be able to understand which argument each bit of code is referring to (or look up the help documentation to check). In this course, we will always write out the argument names the first time we use each function. However, in subsequent uses they may be omitted. 2.1.8 Tab auto-complete One very useful feature of RStudio is tab auto-complete for functions (see Figure 2.1). If you write the name of the function and then press the tab key, RStudio will show you the arguments that function takes along with a brief description. If you press enter on the argument name it will fill in the name for you, just like auto-complete on your phone. This is incredibly useful when you are first learning R and you should remember to use this feature frequently. Figure 2.1: Tab auto-complete 2.2 Objects and the assign (&lt;-) operator A large part of working in R involves creating and manipulating objects. Objects contain stuff. That stuff can be numbers, words, or the result of operations and analyses. You assign content to an object using &lt;-, where the name of the new/updated object appears on the left and the data to be assigned to that object appear on the right. Run the following code in the console, but change the values of name and age to your own details and change christmas to a holiday or date you care about. name &lt;- &quot;Peppa&quot; age &lt;- 4 today &lt;- Sys.Date() christmas &lt;- as.Date(&quot;2022-12-25&quot;) UK_nations &lt;- tibble(nation = c(&quot;Scotland&quot;,&quot;Wales&quot;, &quot;Northern Ireland&quot;, &quot;England&quot;), capital = c(&quot;Edinburgh&quot;, &quot;Cardiff&quot;, &quot;Belfast&quot;, &quot;London&quot;), population = c(5466000, 3169586, 1895510, 56550138)) You'll see that five objects now appear in the environment pane: name is character (text) data. In order for R to recognise it as character data, it must be enclosed in double quotation marks \" \". age is numeric data. In order for R to recognise this as a number, it must not be enclosed in quotation marks. today stores the result of the function Sys.Date(). This function returns your computer system's date. Unlike name and age, which are hard-coded (i.e., they will always return the values you enter), the contents of the object today will change dynamically with the date. That is, if you run that function tomorrow, it will update the date to tomorrow's date. christmas is also a date but it's hard-coded as a very specific date. It's wrapped within the as.Date() function that tells R to interpret the character string you provide as date rather than text. UK_nations - is a \"tibble\" which is basically a table of data (like the way a spreadsheet stores data in rows and columns). Almost always the data we are interested in will be in this type of object or a \"data frame\" which is very similar to a \"tibble\" (and can be converted to one using as_tibble()) Optional Extra Info on tibbles... ...see R for Data Science To print the contents of an object, type the object's name in the console and press enter. Print all five objects by typing: name age today christmas UK_nations Optional Extra Info on print()... Alternatively, the print() function can be used instead of just entering the objects name. One reason to use print() would be to force R to show all the elements of the object using the n= argument which controls how many elements to print. We'll use this function later in this lab. Finally, a key concept to understand is that objects can interact and you can save the results of those interactions in a new object. Run the following code to create these new objects, and then print the contents of each new object. age_in_10_years &lt;- age + 10 full_name &lt;- paste(name, &quot;Pig&quot;) how_long &lt;- christmas - today 2.2.1 The $ operator The dollar sign $ allows you to select items from an object, such as columns from a \"tibble\". The left-hand side of the $ is the object, and the right-hand side is the item. Use this code to extract the populations of the four UK nations from the UK_nations object and store it in a new object called populations then print the new object to check that it contains what you expect: populations &lt;- UK_nations$population populations If your item has multiple observations, you can specify which ones to return using square brackets [] and the position or a vector of positions. Use this code to get a list of the UK nations in the order they appear in the object UK_nations then create an object that contains just the population of Scotland and another object that contains the population of the other UK nations. Print the two objects you created to check that the code did what you expected UK_nations$nation Scotland_capital &lt;- UK_nations$capital[1] # select one observation rUK_capitals &lt;- UK_nations$capital[c(2,3,4)] # select multiple values using c() which creates a vector Scotland_capital rUK_capitals 2.2.2 Code comments In the above code we've used code comments and it's important to highlight how useful these are. You can add comments inside R code with the hash symbol #. R will ignore characters from the hash to the end of the line. 2.2.3 Pipes (%&gt;%) Pipes (%&gt;%) allow you to send the output from one function straight into another function. Specifically, they send the result of the function before %&gt;% to be the first argument of the function after %&gt;%. It can be useful to translate the pipe as \"and then\". It's easier to show than tell, so let's look at an example. We could write the above code using pipes and some new functions from the tidyverse as follows: UK_nations %&gt;% select(nation) # pull out one variable Scotland_capital &lt;- UK_nations %&gt;% select(capital) %&gt;% # choose one variable slice(1) # then choose the first observation in that variable rUK_capitals &lt;- UK_nations %&gt;% filter(nation != &quot;Scotland&quot;) %&gt;% #choose observations that satisfy a condition select(capital) #then choose one variable&#39;s values of the subset of observations Scotland_capital rUK_capitals Optional Extra Info... Although the values in the objects Scotland_capital and rUK_capitals are the same using both sets of code, the \"types\" of objects they are depends on how they are produced (as shown in the different ways they are \"printed\"). We don't need to think too much about the different types of objects in this course. Also, we've the last code used functions select, slice and filter which are part of the dplyr package in tidyverse. We will introduce these functions as we need them, but if you want more information, see this overview, this chapter and/or this Cheat Sheet 2.3 Getting help You will feel like you need a lot of help when you're starting to learn. This won't really go away; it's impossible to memorise everything. The goal is to learn enough about the structure of R that you can look things up quickly. This is why we'll introduce specialised jargon in the glossary for each chapter; it's easier to google \"convert character to numeric in R\" than \"make numbers in quotes be actual numbers not words\". In addition to the function help described above, here's some additional resources you should use often. 2.3.1 Package reference manuals Start up help in a browser by entering help.start() in the console. Click on \"Packages\" under \"Reference\" to see a list of packages. Scroll down to the readxl package and click on it to see a list of the functions that are available in that package. 2.3.2 Googling If the function help doesn't help, or you're not even sure what function you need, try Googling your question. It will take some practice to be able to use the right jargon in your search terms to get what you want. It helps to put \"R\" or \"tidyverse\" in the search text, or the name of the relevant package, like ggplot2. 2.3.3 Vignettes Many packages, especially tidyverse ones, have helpful websites with vignettes explaining how to use their functions. Some of the vignettes are also available inside R. You can access them from a package's help page or with the vignette() function. # opens a list of available vignettes vignette(package = &quot;ggplot2&quot;) # opens a specific vignette in the Help pane vignette(&quot;ggplot2-specs&quot;, package = &quot;ggplot2&quot;) 2.4 Further Resources RStudio IDE Cheatsheet "],["part-2---analyzing-data.html", "3 Part 2 - Analyzing Data 3.1 Intended Learning Outcomes 3.2 Dealing with Data: Great British Bake Off (GBBO) 3.3 dplyr functions for data wrangling", " 3 Part 2 - Analyzing Data 3.1 Intended Learning Outcomes Be introduced to key dplyr functions for data wrangling (part of the tidyverse) Be able to create numerical summaries of data Be able to create graphical summaries of data Be able to create objects by writing and running code in the console 3.2 Dealing with Data: Great British Bake Off (GBBO) The data set we will be looking at in this section refers to TV competition \"Great British Bake Off\" (often abbreviated to \"Bake Off\" or \"GBBO\"). Within each series, a group of amateur bakers compete against each other in a series of episodes, attempting to impress a group of judges with their baking skills. One contestant is eliminated in each episode, and the winner is selected from the contestants who reach the final. The first episode was aired on 17 August 2010, with its first four series broadcast on BBC Two, after which it moved to BBC One for the next three series. After its seventh series, it moved to Channel 4. 3.2.1 Reading data in The text file ratings_seasons.csv contains data on the first 10 series (2010-2019) of GBBO which can be imported using the following code. ratings &lt;- read.csv(url(&quot;https://raw.githubusercontent.com/craigalexander/AdvHStatsLab2/main/ratings_seasons.csv&quot;)) 3.2.2 Looking at data Now that you've loaded some data, look the upper right hand window of RStudio, under the Environment tab. You will see the object ratings listed, along with the number of observations (rows) and variables (columns). This is your first check that you've read in the data correctly. Always look at your data once you've created or loaded it. Also look at it after each step that transforms your data. There are two main ways to look at your data: View() and str(). View() An intuitive way to look at the data is by using View() (uppercase 'V'), which opens up a data table in the console pane using a viewer that looks a bit like an Excel spreadsheet. This command can be useful in the console, but don't ever put this one in a script because it will create an annoying pop-up window when the user runs it. You can also click on an object in the Environment pane to open it in the same interface. You can close the tab when you're done looking at it; it won't remove the object containing the data. View(ratings) str() The funciton str() (short for \"structure\") shows the number of observations and variables and the datatype of those variables, e.g. \"num\" for an number, \"chr\" for a character string (and a lot more information that we don't need to know about!) str(ratings, give.attr=FALSE) #The argument give.attr=FALSE surpresses extra info ## &#39;data.frame&#39;: 94 obs. of 11 variables: ## $ series : int 1 1 1 1 1 1 2 2 2 2 ... ## $ episode : int 1 2 3 4 5 6 1 2 3 4 ... ## $ uk_airdate : chr &quot;2010-08-17&quot; &quot;2010-08-24&quot; &quot;2010-08-31&quot; &quot;2010-09-07&quot; ... ## $ viewers_7day : num 2.24 3 3 2.6 3.03 2.75 3.1 3.53 3.82 3.6 ... ## $ viewers_28day : num 7 3 2 4 1 1 2 2 1 1 ... ## $ network_rank : int NA NA NA NA NA NA NA NA NA NA ... ## $ channels_rank : int NA NA NA NA NA NA NA NA NA NA ... ## $ bbc_iplayer_requests: int NA NA NA NA NA NA NA NA NA NA ... ## $ episode_count : int 1 2 3 4 5 6 7 8 9 10 ... ## $ us_season : int NA NA NA NA NA NA NA NA NA NA ... ## $ us_airdate : chr NA NA NA NA ... Optional: other ways of looking at data It is always necessary to look at the data you are working with to get a good sense of what it contains, i.e. the different types of data contained in the data set and how much data you have. We used the str() function above to get information on the number of variables and observations and to list the variables together with the first few values they take. Alternatively we could use these functions: head(): shows the first 6 lines of the first few variables head(ratings) ## series episode uk_airdate viewers_7day viewers_28day network_rank ## 1 1 1 2010-08-17 2.24 7 NA ## 2 1 2 2010-08-24 3.00 3 NA ## 3 1 3 2010-08-31 3.00 2 NA ## 4 1 4 2010-09-07 2.60 4 NA ## 5 1 5 2010-09-14 3.03 1 NA ## 6 1 6 2010-09-21 2.75 1 NA ## channels_rank bbc_iplayer_requests episode_count us_season us_airdate ## 1 NA NA 1 NA &lt;NA&gt; ## 2 NA NA 2 NA &lt;NA&gt; ## 3 NA NA 3 NA &lt;NA&gt; ## 4 NA NA 4 NA &lt;NA&gt; ## 5 NA NA 5 NA &lt;NA&gt; ## 6 NA NA 6 NA &lt;NA&gt; glimpse(): gives a sideways version of the data. This is useful if the data is very wide (i.e. has lots of variables) and you can't easily see all of the columns/variables. It also tells you the data type of each column/variable in angled brackets after each column/variable name. glimpse(ratings) ## Rows: 94 ## Columns: 11 ## $ series &lt;int&gt; 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3~ ## $ episode &lt;int&gt; 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3~ ## $ uk_airdate &lt;chr&gt; &quot;2010-08-17&quot;, &quot;2010-08-24&quot;, &quot;2010-08-31&quot;, &quot;2010-0~ ## $ viewers_7day &lt;dbl&gt; 2.24, 3.00, 3.00, 2.60, 3.03, 2.75, 3.10, 3.53, 3~ ## $ viewers_28day &lt;dbl&gt; 7, 3, 2, 4, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1~ ## $ network_rank &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ channels_rank &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ bbc_iplayer_requests &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ episode_count &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15~ ## $ us_season &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ ## $ us_airdate &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N~ By using any of the methods described above, answer these questions: How many variables does the data ratings contain? How many observations does ratings contain? In this tutorial we are interested in the ratings of each episode in the 7 day period after its broadcast. What variable contains this information? ratings series episode viewers_7day viewers_28day 3.2.3 Exploring data The variables we will analyse in this tutorial are: series: the series number, ranging from 1 to 10 corresponding to 2010-2019. episode: the episode number, randing from 1 to 10 (although not all series had 10 episodes!) viewers_7day the ratings of each episode in the 7 day period after its broadcast (measured as millions of viewers) Run this code to just see the viewers_7day values in the ratings data: ratings$viewers_7day ## [1] 2.240 3.000 3.000 2.600 3.030 2.750 3.100 3.530 3.820 3.600 ## [11] 3.830 4.250 4.420 5.060 3.850 4.600 4.530 4.710 4.610 4.820 ## [21] 5.100 5.350 5.700 6.740 6.600 6.650 7.170 6.820 6.950 7.320 ## [31] 7.760 7.410 7.410 9.450 8.510 8.790 9.280 10.250 9.950 10.130 ## [41] 10.280 9.023 10.670 13.510 11.620 11.590 12.010 12.360 12.390 12.000 ## [51] 12.350 11.090 12.650 15.050 13.580 13.450 13.010 13.290 13.120 13.130 ## [61] 13.450 13.260 13.440 15.900 9.460 9.230 8.680 8.550 8.610 8.610 ## [71] 9.010 8.950 9.030 10.040 9.550 9.310 8.910 8.880 8.670 8.910 ## [81] 9.220 9.690 9.500 10.340 9.620 9.380 8.940 8.960 9.260 8.700 ## [91] 8.980 9.190 9.340 10.050 What do the numbers in square brackets represent in the output to ratings$viewers_7day? They are part of the data set, i.e. more values of ratings. They don't really have any important meaning. They represent the time taken to run the code in miliseconds. They represent the position of the ratings in the output. i.e. [1] preceeds the first ratings value, [21] preceeds the 21st ratings value. 3.3 dplyr functions for data wrangling We're now going to use some key functions in the dplyr package (part of the tidyverse) to \"wrangle\" data. If you haven't already, load the tidyverse package by copying and running this code in your script file: library(tidyverse) 3.3.1 Creating a new variable and adding it to a data object Not all the information we need is necessarily included in the data. For example, the viewers_7day variable is measured as millions of viewers, but what if we wanted it to be in raw numbers (i.e. 15000000 instead of 1.5)? Also, in the introduction to the GBBO data we were told the \"first four series [were] broadcast on BBC Two, after which it moved to BBC One for the next three series. After its seventh series, it moved to Channel 4.\". We can add this information to the ratings data as another variable/column in the ratings data. Run this code to create a new variables viewers_7day_raw and channel in the ratings data and print it to check that it as we intended: ratings &lt;- mutate(ratings, viewers_7day_raw = viewers_7day * 1000000, channel = case_when(series &lt; 5 ~ &quot;BBC2&quot;, series &gt; 4 &amp; series &lt;8 ~ &quot;BBC1&quot;, series &gt; 7 ~ &quot;C4&quot;)) ratings$viewers_7day_raw select(ratings, series, channel) Before we proceed to creating summarisies of variables we need to pause and think about two types of variables: numeric and categorical. **Run this code again to see the variables (including the one we've just added) in ratings str(ratings) ## &#39;data.frame&#39;: 94 obs. of 13 variables: ## $ series : int 1 1 1 1 1 1 2 2 2 2 ... ## $ episode : int 1 2 3 4 5 6 1 2 3 4 ... ## $ uk_airdate : chr &quot;2010-08-17&quot; &quot;2010-08-24&quot; &quot;2010-08-31&quot; &quot;2010-09-07&quot; ... ## $ viewers_7day : num 2.24 3 3 2.6 3.03 2.75 3.1 3.53 3.82 3.6 ... ## $ viewers_28day : num 7 3 2 4 1 1 2 2 1 1 ... ## $ network_rank : int NA NA NA NA NA NA NA NA NA NA ... ## $ channels_rank : int NA NA NA NA NA NA NA NA NA NA ... ## $ bbc_iplayer_requests: int NA NA NA NA NA NA NA NA NA NA ... ## $ episode_count : int 1 2 3 4 5 6 7 8 9 10 ... ## $ us_season : int NA NA NA NA NA NA NA NA NA NA ... ## $ us_airdate : chr NA NA NA NA ... ## $ viewers_7day_raw : num 2240000 3000000 3000000 2600000 3030000 2750000 3100000 3530000 3820000 3600000 ... ## $ channel : chr &quot;BBC2&quot; &quot;BBC2&quot; &quot;BBC2&quot; &quot;BBC2&quot; ... The values just after the \":\" tells us the type of each variable int stands for integer which is a numeric variable chr stands for 'character' which usually represents a categorical variable Because numbers (e.g. the values that series takes, i.e. 1, 2, 3, ...) can also represent 'categories' or 'levels' of a categorical variable, R doesn't assume that just because a variable is of type chr that it is categorical. To specify a categorical variable in R we use the as.factor() function, since R calls categorical variables \"factors\". In the ratings data the three variables series, episode and channel are categorical variables but they aren't stored as such, yet! To tell R that variables are factors (i.e. categorical) use mutate() to overriding the original variable with the same data but classified as a factor. Copy and run this code to change the series, episode and channel variables to factors. ratings &lt;- ratings %&gt;% mutate(series = as.factor(series), episode = as.factor(episode), channel = as.factor(channel)) str(ratings) ## &#39;data.frame&#39;: 94 obs. of 13 variables: ## $ series : Factor w/ 10 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 1 1 1 1 1 2 2 2 2 ... ## $ episode : Factor w/ 10 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,..: 1 2 3 4 5 6 1 2 3 4 ... ## $ uk_airdate : chr &quot;2010-08-17&quot; &quot;2010-08-24&quot; &quot;2010-08-31&quot; &quot;2010-09-07&quot; ... ## $ viewers_7day : num 2.24 3 3 2.6 3.03 2.75 3.1 3.53 3.82 3.6 ... ## $ viewers_28day : num 7 3 2 4 1 1 2 2 1 1 ... ## $ network_rank : int NA NA NA NA NA NA NA NA NA NA ... ## $ channels_rank : int NA NA NA NA NA NA NA NA NA NA ... ## $ bbc_iplayer_requests: int NA NA NA NA NA NA NA NA NA NA ... ## $ episode_count : int 1 2 3 4 5 6 7 8 9 10 ... ## $ us_season : int NA NA NA NA NA NA NA NA NA NA ... ## $ us_airdate : chr NA NA NA NA ... ## $ viewers_7day_raw : num 2240000 3000000 3000000 2600000 3030000 2750000 3100000 3530000 3820000 3600000 ... ## $ channel : Factor w/ 3 levels &quot;BBC1&quot;,&quot;BBC2&quot;,..: 2 2 2 2 2 2 2 2 2 2 ... You can read this code as, for example, \"overwrite the data that is in the column series with series as a factor, thus converting it to a categorical variable\". Remember this. It's a really important step and if graphs are looking weird this might be the reason. 3.3.2 Creating summaries of data 3.3.2.1 Numerical Data The summarise() function from the dplyr package is loaded as part of the tidyverse and creates summary statistics. It creates a new object with columns that summarise the data from a larger table using summary functions. Check this Cheat Sheet for various summary functions. Some common ones are: n(), min(), max(), mean(), sd() and quantile(). Here is an example using summarise() summarise(ratings, mean_ratings = mean(viewers_7day), sd_ratings = sd(viewers_7day), min_ratings = min(viewers_7day), max_ratings = max(viewers_7day)) ## mean_ratings sd_ratings min_ratings max_ratings ## 1 8.579606 3.266634 2.24 15.9 The first argument that summarise() takes is the data object to summarise summarise() creates a new object. The column names of this new object are on the left hand-side of =, i.e., mean_ratings, sd_ratings, min_ratings and max_ratings. The values of these columns are the result of the summary operation on the right hand-side of =. What is the average number of viewers that GBBO had in the 7 days after broadcast? 3270000 2240000 8580000 15900000 What is the least number of viewers that GBBO had in the 7 days after broadcast: What is the most viewers that GBBO had in the 7 days after broadcast: 3.3.2.2 Categorical Data All of the summaries considered above are relevant for numercial/continuous variables but there also categorical variables in the ratings data. Identify the type of each of the variables in the ratings data: series: discretecontinuousnominalordinal episode: discretecontinuousnominalordinal viewers_7day discretecontinuousnominalordinal channel discretecontinuousnominalordinal The count() function counts the number of rows that are the same. This will give you a new table with each combination of the counted rows and a column called n containing the number of observations from that group. The first argument that count() takes is the data object to summarise The next arguments that count() takes are the variables to summarise The argument sort = TRUE will sort the table by n in descending order. Look at the output from this code and answer the following question: count(ratings, channel, sort = TRUE) ## channel n ## 1 BBC2 34 ## 2 BBC1 30 ## 3 C4 30 Which channel screened the most episodes of GBBO from 2010 to 2019? BBC1BBC2Channel 4No single channel Look at the output from this code and answer the following questions: count(ratings, channel, series) ## channel series n ## 1 BBC1 5 10 ## 2 BBC1 6 10 ## 3 BBC1 7 10 ## 4 BBC2 1 6 ## 5 BBC2 2 8 ## 6 BBC2 3 10 ## 7 BBC2 4 10 ## 8 C4 8 10 ## 9 C4 9 10 ## 10 C4 10 10 What is this summary revealing? The number of episodes within each series (together with what channel broadcast that series) The number of series within each episode (together with what channel broadcast that series) The number of series within each episode The number of episodes within each series How could the order of the columns in the summary table be changed? The order can't be changed count(ratings, series, episode) count(ratings, episode, channel) count(ratings, series, channel) 3.3.2.3 Summarising Numerical and Categorical Data Simultaneously Its seldom that we are interested in just one variable at a time. An example of this is when we want numerical summaries but for each category/group of a categorical variable. The combination of the group_by() and summarise() functions is incredibly powerful for this task (and it is also a good demonstration of why pipes (%&gt;%) are so useful!). The function group_by() takes an existing data object and converts it into a grouped object, where any operations that are performed on it are done \"by group\". Consider this code and its output: ratings_grouped &lt;- ratings %&gt;% group_by(channel) ch_ratings &lt;- ratings_grouped %&gt;% summarise(count = n(), mean_ratings = mean(viewers_7day), min_ratings = min(viewers_7day), max_ratings = max(viewers_7day)) %&gt;% ungroup() ch_ratings ## # A tibble: 3 x 5 ## channel count mean_ratings min_ratings max_ratings ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BBC1 30 12.0 8.51 15.9 ## 2 BBC2 34 5.05 2.24 9.45 ## 3 C4 30 9.19 8.55 10.3 Optional Extra Info on ungroup()... Make sure you call the ungroup() function when you are done with grouped functions. Failing to do this can cause all sorts of mysterious problems if you use that data object later assuming it isn't grouped. The first line of code below creates an object named ratings_grouped, that groups the data according to what channel the episode was broadcast on. On the surface, ratings_grouped doesn't look any different to the original ratings data. However, the underlying structure has changed and so when we run summarise(), we now get our requested summaries for each group (in this case for each channel). Whilst the above code is functional, it adds an unnecessary object to the environment - ratings_grouped is taking up space and increases the risk we'll use this grouped object by mistake. A better way to do this is to use the pipe (&gt;%&gt;. Rather than creating an intermediate object, we can use the pipe to string our code together. Run this code and check that the object produced is identical to ch_ratings shown above. ch_ratings &lt;- ratings %&gt;% # Start with the original dataset; and then group_by(channel) %&gt;% # group it; and then summarise(count = n(), # summarise it by those groups mean_ratings = mean(viewers_7day), min_ratings = min(viewers_7day), max_ratings = max(viewers_7day)) %&gt;% ungroup() What would you change to calculate the mean ratings by series instead of by channel? group_by(series) summarise(series) count(series) mean(series) You can add multiple variables to group_by() to further break down your data. For example, the below gives us the average ratings broken down by channel and series. Reverse the order of channel and series in group_by() to see how it changes the output. ch_series_ratings &lt;- ratings %&gt;% group_by(channel, series) %&gt;% summarise(count = n(), mean_ratings = mean(viewers_7day), min_ratings = min(viewers_7day), max_ratings = max(viewers_7day)) %&gt;% ungroup() ch_series_ratings ## # A tibble: 10 x 6 ## channel series count mean_ratings min_ratings max_ratings ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 BBC1 5 10 10.0 8.51 13.5 ## 2 BBC1 6 10 12.3 11.1 15.0 ## 3 BBC1 7 10 13.6 13.0 15.9 ## 4 BBC2 1 6 2.77 2.24 3.03 ## 5 BBC2 2 8 3.95 3.1 5.06 ## 6 BBC2 3 10 5.00 3.85 6.74 ## 7 BBC2 4 10 7.35 6.6 9.45 ## 8 C4 8 10 9.02 8.55 10.0 ## 9 C4 9 10 9.30 8.67 10.3 ## 10 C4 10 10 9.24 8.7 10.0 Which code lists the summaries in chronological order? group_by(channel, series)group_by(series, channel)Neither of these "],["visualizing-data.html", "4 Visualizing Data 4.1 Building plots 4.2 Counting categories 4.3 One continuous variable 4.4 Grouped continuous variables 4.5 Two continuous variables 4.6 Two continuous variables and a categorical variable", " 4 Visualizing Data 4.1 Building plots There are multiple approaches to data visualisation in R; in this course we will use the popular package ggplot2, which is part of the larger tidyverse collection of packages. A grammar of graphics (the \"gg\" in \"ggplot\") is a standardised way to describe the components of a graphic. ggplot2 uses a layered grammar of graphics, in which plots are built up in a series of layers. It may be helpful to think about any picture as having multiple elements that sit semi-transparently over each other. Figure 1 displays the steps to create a simple scatterplot using this layered approach. First, the plot space is built (layer 1); the variables are specified (layer 2); the type of visualisation (known as a geom) that is desired for these variables is specified (layer 3) - in this case geom_point() is called to visualise individual data points; a second geom is added to include a line of best fit (layer 4), the axis labels are edited for readability (layer 5), and finally, a theme is applied to change the overall appearance of the plot (layer 6). Figure 4.1: Figure 1: Steps to create a layered plot Importantly, each layer is independent and independently customisable. For example, the size, colour and position of each component can be adjusted. The use of layers makes it easy to build up complex plots step-by-step, and to adapt or extend plots from existing code. Using the concept of building up a plot by layers, we will describe some specific plot types. Different types of data require different types of plots, so the following sections are organised by data type. The ggplot2 cheat sheet is a great resource to help you find plots appropriate to your data, based on how many variables you're plotting and what type they are. The examples below all use the GBBO data, but each plot communicates something different. We don't expect you to memorise all of the plot types or the methods for customising them, but it will be helpful to try out the code in the examples below for yourself, changing values to test your understanding. 4.2 Counting categories 4.2.1 Bar plot If you want to count the number of things per category, you can use geom_bar(). You only need to provide a x mapping to geom_bar() because by default geom_bar() uses the number of observations in each group of x as the value for y, so you don't need to tell it what to put on the y-axis. ggplot(ratings, aes(x = channel)) + geom_bar() Notice that layers are added using the plus + symbol at the end of the previous line, not at the start of the next line. For example if you make this mistake: ggplot(ratings, aes(x = channel)) + geom_bar() ...it will produce an empty 'base layer' and then an error like this: ## Error: ## ! Cannot use `+.gg()` with a single argument. Did you accidentally put + on a new line? Inspect the code below and try running it layer by layer to figure out how things like the order of the columns and their labels change. ggplot(ratings, aes(x = channel, fill = channel)) + geom_bar() + labs(title=&quot;Number of episodes of GBBO broadcast on each channel&quot;)+ # adds a plot title ylab(&quot;Number of Episodes&quot;)+ # adds an axis label theme(legend.position = &quot;none&quot;)+ # removes the legend scale_x_discrete( # change axis label name = &quot;Broadcast Channels (in chronological order)&quot;, # change to chronological order limits = c(&quot;BBC2&quot;, &quot;BBC1&quot;, &quot;C4&quot;), # change labels labels = c(&quot;BBC 2&quot;, &quot;BBC 1&quot;, &quot;Channel 4&quot;) ) Copy and edit the code above to produce a bar plot showing the number of episodes in each series of GBBO Solution ggplot(ratings, aes(x = series, fill = series)) + geom_bar() + labs(title=&quot;Number of episodes of GBBO broadcast in each series&quot;)+ # adds a plot title ylab(&quot;Number of Episodes&quot;)+ # adds an axis label xlab(&quot;Series&quot;)+ # adds an axis label theme(legend.position = &quot;none&quot;)+ # removes the legend scale_x_discrete( # change to categorical labels limits = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;), # change labels labels = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;) ) 4.2.2 Column plot If your data already have a column with the number you want to be the height of each bar or column, you can use geom_col() to plot it. Recall that the ratings data contains the variable viewers_7day which contains the number of viewers in the 7 days after each episode which we can plot as the height of each bar/column by setting y=viewers_7day. But what will we use to define where they are plotted on the x-axis? After considering the values contained in the variable series and/or episode complete this statement: Neither the values in series or episode can be used to define x=: TRUEFALSE Explanation select(ratings,series,episode) ## series episode ## 1 1 1 ## 2 1 2 ## 3 1 3 ## 4 1 4 ## 5 1 5 ## 6 1 6 ## 7 2 1 ## 8 2 2 ## 9 2 3 ## 10 2 4 ## 11 2 5 ## 12 2 6 ## 13 2 7 ## 14 2 8 ## 15 3 1 ## 16 3 2 ## 17 3 3 ## 18 3 4 ## 19 3 5 ## 20 3 6 ## 21 3 7 ## 22 3 8 ## 23 3 9 ## 24 3 10 ## 25 4 1 ## 26 4 2 ## 27 4 3 ## 28 4 4 ## 29 4 5 ## 30 4 6 ## 31 4 7 ## 32 4 8 ## 33 4 9 ## 34 4 10 ## 35 5 1 ## 36 5 2 ## 37 5 3 ## 38 5 4 ## 39 5 5 ## 40 5 6 ## 41 5 7 ## 42 5 8 ## 43 5 9 ## 44 5 10 ## 45 6 1 ## 46 6 2 ## 47 6 3 ## 48 6 4 ## 49 6 5 ## 50 6 6 ## 51 6 7 ## 52 6 8 ## 53 6 9 ## 54 6 10 ## 55 7 1 ## 56 7 2 ## 57 7 3 ## 58 7 4 ## 59 7 5 ## 60 7 6 ## 61 7 7 ## 62 7 8 ## 63 7 9 ## 64 7 10 ## 65 8 1 ## 66 8 2 ## 67 8 3 ## 68 8 4 ## 69 8 5 ## 70 8 6 ## 71 8 7 ## 72 8 8 ## 73 8 9 ## 74 8 10 ## 75 9 1 ## 76 9 2 ## 77 9 3 ## 78 9 4 ## 79 9 5 ## 80 9 6 ## 81 9 7 ## 82 9 8 ## 83 9 9 ## 84 9 10 ## 85 10 1 ## 86 10 2 ## 87 10 3 ## 88 10 4 ## 89 10 5 ## 90 10 6 ## 91 10 7 ## 92 10 8 ## 93 10 9 ## 94 10 10 # Notice that neither series nor episode contain unique values, which would be necessary to define the position on the x-axis for each of the columns with height equal to the ratings (viewers_7day) So before we can create the column plot, we need to create a new variable: Run this code to create a new variable ep_id which is the unique index indicating the chronological order of each episode (using the row_number() function and the fact that it's the same as the order it appears in the ratings data). ratings &lt;- ratings %&gt;% mutate(ep_id = row_number()) Now we have the two variables we need to make the column plot. Inspect and run this code to produce the plot below. ggplot(ratings, aes(x = ep_id, y = viewers_7day, fill = series)) + geom_col() + labs(title=&quot;7-Day Viewers across All Series/Episodes&quot;)+ ylab(&quot;Number of viewers (millions)&quot;)+ # adds an axis label xlab(&quot;Episode Index&quot;)+ # adds an axis label scale_fill_discrete(name=&quot;Series&quot;) # set the name of the legend 4.2.3 Pie chart Pie charts are a misleading form of data visualisation, so we won't cover them. 4.2.4 Test your understanding Here is a small data table. country population island Northern Ireland 1,895,510 Ireland Wales 3,169,586 Great Britain Republic of Ireland 4,937,786 Ireland Scotland 5,466,000 Great Britain England 56,550,138 Great Britain What geom would you use to plot the population for each of the 5 countries? geom_bargeom_col What mapping would you use? aes(x = country, y = population) aes(x = population, y = country) aes(x = country) aes(x = island) aes(y = population) What geom would you use to plot the number of countries on each island? geom_bargeom_col What mapping would you use? aes(x = country, y = population) aes(x = population, y = country) aes(x = country) aes(x = island) aes(y = population) 4.3 One continuous variable If you have a continuous variable, like the number of views 7 days after each broadcast, you can use geom_histogram() or geom_density() to show the distribution. Just like geom_bar() you are only required to specify the x variable. 4.3.1 Histogram A histogram splits the data into \"bins\" along the x-axis and shows the count of how many observations are in each bin along the y-axis. ggplot(ratings, aes(x = viewers_7day)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 4.2: Histogram of ratings. You should always set the binwidth or number of bins to something meaningful for your data (otherwise you get an annoying message, like the one above). You might need to try a few options before you find something that looks good and conveys the meaning of your plot. Try changing the values of binwidth and bins below to see what works best. # adjust width of each bar ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 2) # adjust number of bars ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(bins = 5) Finally, the default style of grey bars is ugly, so you can change that by setting the fill and colour, as well as using scale_x_continuous() to update the axis labels. Adapt and run this code to control the appearance of the histogram ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 1, boundary = 0, fill = &quot;white&quot;, color = &quot;black&quot;) + scale_x_continuous(name = &quot;Number of viewers 7 days after broadcast (in millions)&quot;) Solution ggplot(ratings, aes(x = viewers_7day)) + geom_histogram(binwidth = 1, boundary = 0, fill = &quot;white&quot;, color = &quot;black&quot;) + scale_x_continuous(name = &quot;Number of viewers 7 days after broadcast (in millions)&quot;) 4.4 Grouped continuous variables There are several ways to compare continuous data across groups. Which you choose depends on what point you are trying to make with the plot. 4.4.1 Subdividing distributions In previous plots, we have used fill purely for visual reasons, e.g., we have changed the colour of the histogram bars to make them look nicer. However, you can also use fill to represent another variable so that the colours become meaningful. Setting the fill aesthetic in the mapping will produce different coloured bars for each category of the fill variable, in this case issue_category. ggplot(ratings, aes(x = viewers_7day, fill = channel)) + geom_histogram(binwidth = 1, color = &quot;black&quot;) Figure 4.3: Histogram with categories represented by fill. 4.4.2 Violin plot Another way to compare groups of continuous variables is the violin plot. This is like a density plot, but rotated 90 degrees and mirrored - the fatter the violin, the larger proportion of data points there are at that value. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_violin() + ggtitle(&#39;scale = &quot;area&quot;&#39;) Figure 4.4: The default violin plot gives each shape the same area. Set scale='count' to make the size proportional to the number of observations. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_violin(scale = &quot;count&quot;) + ggtitle(&#39;scale = &quot;count&quot;&#39;) 4.4.3 Boxplot Boxplots serve a similar purpose to violin plots. They don't show you the shape of the distribution, but rather some statistics about it. The middle line represents the median; half the data are above this line and half below it. The box encloses the 25th to 75th percentiles of the data, so 50% of the data falls inside the box. The \"whiskers\" extending above and below the box extend 1.5 times the height of the box, although you can change this with the coef argument. The points show outliers -- individual data points that fall outside of this range. ggplot(ratings, aes(x = channel, y = viewers_7day)) + geom_boxplot() Figure 4.5: Basic boxplot. 4.4.4 Test your understanding How would you create plot A? geom_box()geom_boxplot()geom_violin()geom_violinplot() How would you create plot B? geom_box()geom_boxplot()geom_violin()geom_violinplot() What does the mapping look like for both plots? aes(x = series, y = viewers_7day, colour = series) aes(x = series, y = viewers_7day, colour = viewers_7day) aes(x = series, y = viewers_7day, fill = series) aes(x = series, y = viewers_7day, fill = viewers_7day) Which series had the highest ratings? 12345678910 Which channel brodcast the series with the highest ratings? (You need to think back to answer this question) BBC 1BBC 2Channel 4 4.5 Two continuous variables When you want to see how two continuous variables are related, set one as the x-axis and the other as the y-axis. For example, what if we want to see the changes in ratings over the episodes/series in chronological order. 4.5.1 Scatterplot The function to create a scatterplot is called geom_point(). ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_point() Figure 4.6: Scatterplot with geom_point(). Edit and run the above code to join up the points in the scatterplot by adding the function + geom_line and then modify the code further to remove the points Solution ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_point()+ geom_line()+ ggtitle(&quot;Scatterplot with both points and lines&quot;) ggplot(ratings, aes(x = ep_id, y = viewers_7day)) + geom_line()+ ggtitle(&quot;Scatterplot with just lines&quot;) These plots show each individual episodes' ratings and are perhaps more detailed than we need. If we were just interested in looking at the ratings across series, then we could create summaries for each series and plot these. Examine and run this code to produce a lineplot of the average ratings for each series avg_ratings &lt;- ratings %&gt;% select(series, episode, viewers_7day) %&gt;% group_by(series) %&gt;% summarise(avg_viewers_7day = mean(viewers_7day)) %&gt;% ungroup() ggplot(avg_ratings, aes(x = series, y = avg_viewers_7day, group=1)) + geom_point() + geom_line() + ggtitle(&quot;Great British Bake Off Average Ratings&quot;) Optional: Why do we need group=1 Because the x values in aes() are a factor, by default geom_line() treats each unique x value as a separate group and tries to connect points only inside each group. Setting group=1 in aes() ensures that all values are treated as one group (and therefore connected by lines using geom_line()). 4.6 Two continuous variables and a categorical variable It is often the case that we are interested in relationships between more then two variables. The code below illustrates how to build more complex graphical summaries, in this case number of viewers of the first and last episode in each series. You do not need to produce this plot but have a look and see if you can follow the code that is used to create it. plot_data &lt;- ratings %&gt;% select(series, episode, viewers_7day) %&gt;% group_by(series) %&gt;% filter(episode == 1 | episode == max(as.numeric(episode))) %&gt;% mutate(episode = recode(episode, &quot;1&quot; = &quot;first&quot;, .default = &quot;last&quot;)) %&gt;% ungroup() ggplot(plot_data, aes(x = series, y = viewers_7day, color = episode, group = episode )) + geom_point() + geom_line() + ggtitle(&quot;Great British Bake Off Finales Get More Viewers than Premiers&quot;) + labs(color = &quot;Episode&quot;) "],["extra-tasks.html", "5 Extra Tasks 5.1 BFRSS Survey Questions", " 5 Extra Tasks 5.1 BFRSS Survey Questions The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. As its name implies, the BRFSS is designed to identify risk factors in the adult population and report emerging health trends. For example, respondents are asked about their diet and weekly physical activity, their HIV/AIDS status, possible tobacco use, and even their level of healthcare coverage. The BRFSS Web site contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data. You will focus on a random sample of 20,000 people from the BRFSS survey conducted in 2000. While there are over 200 variables in this data set, you will work with a small subset. Load the data set of 20,000 observations into the object cdc and look at what it contains by running the following code. It may take a couple of minutes for the data to load, depending on your internet connection, so be patient! source(&quot;http://www.openintro.org/stat/data/cdc.R&quot;) str(cdc) Make a scatterplot of weight (in pounds) versus desired weight (in pounds). Describe the relationship between these two variables. It may be helpful to add the command + geom_abline() onto the end of your plot code, which adds in the y = x line. Let's consider a new variable: the difference between desired weight (wtdesire) and current weight (weight). Create this new variable by subtracting the two columns in the data frame and assigning them to a new object called wdiff. What type of data is wdiff? If an observation wdiff is 0, what does this mean about the person's weight and desired weight. What if wdiff is positive or negative? Describe the distribution of wdiff in terms of its center, shape, and spread, including any plots you use. What does this tell us about how people feel about their current weight? Using numerical summaries and a side-by-side box plot, determine if men tend to view their weight differently than women. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
